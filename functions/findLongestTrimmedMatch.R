# Function to find the longest common substring alignment between seq1 and seq2,
# where the substring is seq1 or seq1 trimmed from the start OR end,
# and seq2 is always longer than seq1. The match must be perfect.
# Returns the substring, its start position in seq2, and its end position in seq2.

#Code generated by Google Gemini 2.5 Pro on April 1, 2025

findLongestTrimmedMatch <- function(seq1, seq2) {
  
  # Ensure inputs are character strings
  if (!is.character(seq1) || !is.character(seq2) || length(seq1) != 1 || length(seq2) != 1) {
    stop("Inputs seq1 and seq2 must be single character strings.")
  }
  
  n1 <- nchar(seq1)
  n2 <- nchar(seq2)
  
  # Handle empty sequences
  if (n1 == 0 || n2 == 0) {
    warning("One or both input sequences are empty.")
    return(list(substring = "", start = NA, end = NA, length = 0))
  }
  
  longest_sub <- ""
  start_pos_in_seq2 <- NA
  end_pos_in_seq2 <- NA
  max_len <- 0
  
  # Iterate through possible lengths of substrings, from longest (n1) down to 1
  for (len in n1:1) {
    found_match_at_this_length <- FALSE
    # Iterate through all possible starting positions in seq1 for the current length
    for (start1 in 1:(n1 - len + 1)) {
      # Extract the substring from seq1
      current_sub <- substring(seq1, start1, start1 + len - 1)
      
      # Check if this substring exists in seq2 using regexpr for position
      # regexpr finds the *first* occurrence
      # fixed = TRUE ensures we treat the substring literally, not as a regex pattern
      match_info <- regexpr(current_sub, seq2, fixed = TRUE) 
      
      # regexpr returns -1 if no match is found
      if (match_info[1] != -1) {
        # Match found! Since we iterate from longest length down, this is the longest
        longest_sub <- current_sub
        max_len <- len
        start_pos_in_seq2 <- match_info[1] # Start position is the first element
        # Get the length of the match (should be 'len', but good practice)
        match_length <- attr(match_info, "match.length")[1] 
        end_pos_in_seq2 <- start_pos_in_seq2 + match_length - 1
        
        found_match_at_this_length <- TRUE
        break # Exit the inner loop (no need to check shorter starts for this length)
      }
    }
    # If we found a match at this length, we can stop searching shorter lengths
    if (found_match_at_this_length) {
      break # Exit the outer loop
    }
  }
  
  # Return the results as a list
  return(list(
    substring = longest_sub,
    start = start_pos_in_seq2,
    end = end_pos_in_seq2,
    length = max_len
  ))
}